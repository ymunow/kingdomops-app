KingdomOps – Application Review Flow (Agent Brief)
Goals (Acceptance Criteria)
A persistent Application table (no more disappearing submissions).
Admin queue: list of apps by status (Pending / Approved / Rejected).
Admin review page: shows pastor’s answers + attachments + reviewer notes.
Approve → creates an Organization and links it to the application.
Reject → stores reason, does not create an org.
Dashboard tiles show correct counts and link to the correct pages.
“Review Application” buttons open the review page, not the org dashboard.
Stack Assumptions
Backend: Node + Express (seen in logs).
Auth: Supabase (leave as-is; routes remain behind existing admin guard).
DB:
If Supabase/Postgres already exists → use Postgres in Prisma.
If no DB / or in-memory → use SQLite locally via Prisma.
Step 0 — Dependencies & Project Hygiene
Install deps (TypeScript or JS—agent can detect and adjust types):
npm i express body-parser slugify cors
npm i @prisma/client
npm i -D prisma

# If TypeScript project:
npm i -D typescript ts-node @types/node @types/express @types/cors @types/body-parser
If Postgres with Supabase is available, set:
.env
DATABASE_URL="postgresql://<user>:<pass>@<host>:5432/<db>?schema=public"
Otherwise default to SQLite:
.env
DATABASE_URL="file:./dev.db"
Step 1 — Prisma Setup
Initialize (if not already):
npx prisma init --datasource-provider sqlite
# If using Postgres, change provider to "postgresql" and set DATABASE_URL accordingly.
Replace/merge prisma/schema.prisma:
datasource db {
  provider = env("PRISMA_PROVIDER") // optional; else put "sqlite" or "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum AppStatus {
  PENDING
  APPROVED
  REJECTED
}

model Application {
  id             String      @id @default(cuid())
  status         AppStatus   @default(PENDING)

  churchName     String
  primaryContact String
  email          String
  phone          String?
  subdomain      String?

  answers        Json
  attachments    Json?

  reviewedById   String?
  reviewedAt     DateTime?
  decisionNotes  String?

  organizationId String?     @unique
  organization   Organization? @relation(fields: [organizationId], references: [id])

  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
}

model Organization {
  id           String   @id @default(cuid())
  name         String
  subdomain    String   @unique
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  application  Application?
}
Generate + migrate:
npx prisma generate
npx prisma migrate dev --name app_review_flow
Step 2 — Backend Code
Create src/lib/prisma.ts:
import { PrismaClient } from '@prisma/client'
export const prisma = new PrismaClient()
Create src/routes/adminApplications.ts:
import { Router } from 'express'
import { prisma } from '../lib/prisma'
import slugify from 'slugify'

const r = Router()

r.get('/', async (req, res) => {
  const status = (req.query.status as string) || 'PENDING'
  const items = await prisma.application.findMany({
    where: { status: status as any },
    orderBy: { createdAt: 'desc' }
  })
  res.json(items)
})

r.get('/:id', async (req, res) => {
  const app = await prisma.application.findUnique({ where: { id: req.params.id } })
  if (!app) return res.status(404).json({ error: 'Not found' })
  res.json(app)
})

r.post('/:id/approve', async (req, res) => {
  const id = req.params.id
  const { notes, subdomain } = req.body || {}

  const appRec = await prisma.application.findUnique({ where: { id } })
  if (!appRec) return res.status(404).json({ error: 'Not found' })
  if (appRec.status !== 'PENDING') return res.status(400).json({ error: 'Invalid state' })

  const finalSub = subdomain || slugify(appRec.churchName, { lower: true, strict: true })

  const org = await prisma.organization.create({
    data: { name: appRec.churchName, subdomain: finalSub }
  })

  await prisma.application.update({
    where: { id },
    data: {
      status: 'APPROVED',
      organizationId: org.id,
      reviewedById: 'admin', // TODO: swap with real admin id
      reviewedAt: new Date(),
      decisionNotes: notes || null
    }
  })

  res.json({ ok: true, organizationId: org.id })
})

r.post('/:id/reject', async (req, res) => {
  const id = req.params.id
  const { reason } = req.body || {}

  const appRec = await prisma.application.findUnique({ where: { id } })
  if (!appRec) return res.status(404).json({ error: 'Not found' })
  if (appRec.status !== 'PENDING') return res.status(400).json({ error: 'Invalid state' })

  await prisma.application.update({
    where: { id },
    data: {
      status: 'REJECTED',
      reviewedById: 'admin',
      reviewedAt: new Date(),
      decisionNotes: reason || null
    }
  })

  res.json({ ok: true })
})

export default r
Register the router (e.g., src/server.ts):
import express from 'express'
import cors from 'cors'
import bodyParser from 'body-parser'
import adminApplications from './routes/adminApplications'

const app = express()
app.use(cors())
app.use(bodyParser.json())

app.use('/api/admin/applications', adminApplications)

// existing routes…

const PORT = process.env.PORT || 5000
app.listen(PORT, () => console.log(`API on http://localhost:${PORT}`))
Step 3 — Seed Data
Create prisma/seed.ts:
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()

async function main() {
  const exists = await prisma.application.count()
  if (exists) return

  await prisma.application.create({
    data: {
      churchName: 'Grace Heritage Ministries',
      primaryContact: 'Pastor John Doe',
      email: 'pastor@example.com',
      subdomain: 'grace-heritage',
      answers: {
        "Mission focus": "Discipleship and community outreach",
        "Denomination": "Non-denominational",
        "Average attendance": "230",
        "Why join beta?": "Pilot assessments and volunteer matching"
      },
      attachments: [{ name: '501c3.pdf', url: 'https://example.com/501c3.pdf' }]
    }
  })
}

main().finally(() => prisma.$disconnect())
If TypeScript:
npx ts-node prisma/seed.ts
If JS, rename to seed.js and run:
node prisma/seed.js
Step 4 — Frontend Pages
Queue page: /admin/applications
src/pages/admin/applications/index.tsx
import { useEffect, useState } from 'react'

export default function ApplicationsList() {
  const [items, setItems] = useState<any[]>([])
  const [status, setStatus] = useState('PENDING')

  useEffect(() => {
    fetch(`/api/admin/applications?status=${status}`).then(r => r.json()).then(setItems)
  }, [status])

  return (
    <div className="max-w-5xl mx-auto p-6 space-y-4">
      <h1 className="text-2xl font-semibold">Beta Applications</h1>
      <div className="flex gap-2">
        {['PENDING','APPROVED','REJECTED'].map(s => (
          <button key={s} onClick={() => setStatus(s)}
            className={`px-3 py-1 rounded ${status===s?'bg-indigo-600 text-white':'border'}`}>
            {s}
          </button>
        ))}
      </div>
      <div className="divide-y border rounded-lg">
        {items.map(app => (
          <div key={app.id} className="p-4 flex items-center justify-between">
            <div>
              <div className="font-medium">{app.churchName}</div>
              <div className="text-sm text-gray-500">{app.primaryContact} • {app.email}</div>
            </div>
            <a className="px-3 py-2 rounded bg-emerald-600 text-white"
               href={`/admin/applications/${app.id}`}>Review</a>
          </div>
        ))}
        {!items.length && <div className="p-6 text-gray-500">No applications</div>}
      </div>
    </div>
  )
}
Review page: /admin/applications/:id
src/pages/admin/applications/[id].tsx
import { useEffect, useState } from 'react'

export default function ApplicationReview() {
  const id = window.location.pathname.split('/').pop()!
  const [app, setApp] = useState<any>(null)
  const [notes, setNotes] = useState('')

  useEffect(() => {
    fetch(`/api/admin/applications/${id}`).then(r => r.json()).then(setApp)
  }, [id])

  if (!app) return <div className="p-6">Loading…</div>

  const approve = async () => {
    const r = await fetch(`/api/admin/applications/${id}/approve`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ notes, subdomain: app.subdomain })
    }).then(r => r.json())
    alert('Approved! Opening org dashboard…')
    window.location.href = `/admin/orgs/${r.organizationId}`
  }

  const reject = async () => {
    await fetch(`/api/admin/applications/${id}/reject`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ reason: notes || 'Not a fit for beta' })
    })
    alert('Application rejected.')
    window.location.href = '/admin/applications'
  }

  return (
    <div className="max-w-5xl mx-auto p-6 space-y-6">
      <header className="flex items-center justify-between">
        <h1 className="text-2xl font-semibold">Review — {app.churchName}</h1>
        <span className="px-3 py-1 rounded-full bg-yellow-100 text-yellow-900 text-sm">{app.status}</span>
      </header>

      <section className="grid md:grid-cols-2 gap-6">
        <div className="border rounded-lg p-4">
          <h2 className="font-medium mb-2">Primary Contact</h2>
          <div>{app.primaryContact}</div><div>{app.email}</div><div>{app.phone || '—'}</div>
        </div>
        <div className="border rounded-lg p-4">
          <h2 className="font-medium mb-2">Requested URL</h2>
          <div>{app.subdomain ? `${app.subdomain}.kingdomops.org` : '—'}</div>
        </div>
        <div className="border rounded-lg p-4 md:col-span-2">
          <h2 className="font-medium mb-3">Application Answers</h2>
          <ul className="space-y-3">
            {Object.entries(app.answers || {}).map(([q, a]: any) => (
              <li key={q}><div className="text-sm text-gray-500">{q}</div>
              <div className="font-medium">{String(a)}</div></li>
            ))}
          </ul>
        </div>
        {Array.isArray(app.attachments) && app.attachments.length > 0 && (
          <div className="border rounded-lg p-4 md:col-span-2">
            <h2 className="font-medium mb-3">Attachments</h2>
            <ul className="list-disc ml-6">
              {app.attachments.map((f: any) => (
                <li key={f.url}><a href={f.url} target="_blank" rel="noreferrer">{f.name}</a></li>
              ))}
            </ul>
          </div>
        )}
      </section>

      <section className="border rounded-lg p-4">
        <h2 className="font-medium mb-2">Reviewer Notes</h2>
        <textarea className="w-full border rounded p-3" rows={4}
          value={notes} onChange={e => setNotes(e.target.value)} />
      </section>

      <footer className="flex gap-3">
        <button onClick={approve} className="px-4 py-2 rounded bg-emerald-600 text-white">Approve</button>
        <button onClick={reject}  className="px-4 py-2 rounded bg-rose-600 text-white">Reject</button>
        <a href="/admin/applications" className="ml-auto px-4 py-2 rounded border">Back to Queue</a>
      </footer>
    </div>
  )
}
Step 5 — Dashboard Tiles
Backend helper (or inline where you build the dashboard):
import { prisma } from '../lib/prisma'
export async function getDashboardCounts() {
  const [pending, approvedApps, activeOrgs] = await Promise.all([
    prisma.application.count({ where: { status: 'PENDING' }}),
    prisma.application.count({ where: { status: 'APPROVED' }}),
    prisma.organization.count()
  ])
  return { pending, approvedApps, activeOrgs }
}
Tile links:
Pending → /admin/applications?status=PENDING
Approved → /admin/applications?status=APPROVED
Active → /admin/orgs
Change existing “Review Application” buttons to link to /admin/applications/:id.
Step 6 — Smoke Tests
Start API and frontend. Then in a terminal:
# List pending apps
curl http://localhost:5000/api/admin/applications?status=PENDING

# Get one (replace <ID>)
curl http://localhost:5000/api/admin/applications/<ID>

# Approve (returns organizationId)
curl -X POST http://localhost:5000/api/admin/applications/<ID>/approve \
  -H "Content-Type: application/json" \
  -d '{"notes":"Looks good"}'

# Reject (use a fresh pending ID)
curl -X POST http://localhost:5000/api/admin/applications/<ID>/reject \
  -H "Content-Type: application/json" \
  -d '{"reason":"Missing info"}'
Manual UI:
Visit /admin/applications → see Grace Heritage.
Click Review → see answers and attachments.
Click Approve → redirected to /admin/orgs/{newOrgId}.
Tile counts reflect the new state.
Guardrails
Do not auto-create organizations on submission; only on Approve.
Keep auth middleware (Super Admin) on these routes.
If you already have an Organization model, merge fields; don’t duplicate.
If using Postgres/Supabase, set Prisma provider to postgresql and reuse the same DB.