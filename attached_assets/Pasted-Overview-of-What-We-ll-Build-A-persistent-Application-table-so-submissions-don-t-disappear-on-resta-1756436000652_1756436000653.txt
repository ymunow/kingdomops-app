Overview of What We’ll Build
A persistent Application table (so submissions don’t disappear on restart).
Admin queue page (list of pending apps).
Admin review page (shows pastor’s answers, attachments, notes).
Approve = creates the Church Organization and links it.
Reject = records reason, stays out of the org dashboard.
Dashboard tiles wired to the right counts.
Part 0 — Prereqs (do once)
Install Node LTS: https://nodejs.org/en/download
Open your project folder in VS Code (or your editor).
In a terminal at your project root:
node -v
npm -v
If you don’t have a database yet (your data vanishes on restart), we’ll add SQLite for dev (super simple) using Prisma.
Part 1 — Add Prisma + SQLite (Persistence)
Skip to Part 2 if you already use Prisma.
Install Prisma:
npm i -D prisma
npx prisma init --datasource-provider sqlite
This creates:
prisma/schema.prisma
.env with DATABASE_URL="file:./dev.db"
Open prisma/schema.prisma and replace its content with this base (or merge if you already have Organization or other models):
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum AppStatus {
  PENDING
  APPROVED
  REJECTED
}

model Application {
  id             String     @id @default(cuid())
  status         AppStatus  @default(PENDING)

  churchName     String
  primaryContact String
  email          String
  phone          String?
  subdomain      String?    // requested subdomain

  answers        Json       // key/value of Q&A
  attachments    Json?      // array of {name,url}

  reviewedById   String?
  reviewedAt     DateTime?
  decisionNotes  String?

  organizationId String?    @unique
  organization   Organization? @relation(fields: [organizationId], references: [id])

  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
}

model Organization {
  id        String   @id @default(cuid())
  name      String
  subdomain String   @unique
  // add any other fields you already track…
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  application Application?
}
Install the Prisma client and run your first migration:
npm i @prisma/client
npx prisma migrate dev --name init_db
This creates dev.db (a SQLite file) under /prisma.
Part 2 — Backend API (Node/Express)
If your backend is already Express: add these routes.
If you’re using Next.js API Routes or Nest/Laravel/Rails, keep the method names and adapt the code.
Create a Prisma helper src/lib/prisma.ts:
// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client'
export const prisma = new PrismaClient()
Admin Applications Router src/routes/adminApplications.ts:
import { Router } from 'express'
import { prisma } from '../lib/prisma'
import slugify from 'slugify'

const r = Router()

// LIST: /api/admin/applications?status=PENDING|APPROVED|REJECTED
r.get('/', async (req, res) => {
  const status = (req.query.status as string) || 'PENDING'
  const items = await prisma.application.findMany({
    where: { status },
    orderBy: { createdAt: 'desc' },
  })
  res.json(items)
})

// GET ONE: /api/admin/applications/:id
r.get('/:id', async (req, res) => {
  const app = await prisma.application.findUnique({
    where: { id: req.params.id },
  })
  if (!app) return res.status(404).json({ error: 'Not found' })
  res.json(app)
})

// APPROVE: creates Organization and links it
r.post('/:id/approve', async (req, res) => {
  const id = req.params.id
  const { notes, subdomain } = req.body || {}

  const appRec = await prisma.application.findUnique({ where: { id } })
  if (!appRec) return res.status(404).json({ error: 'Not found' })
  if (appRec.status !== 'PENDING') return res.status(400).json({ error: 'Invalid state' })

  const finalSub = subdomain || slugify(appRec.churchName, { lower: true, strict: true })

  const org = await prisma.organization.create({
    data: {
      name: appRec.churchName,
      subdomain: finalSub,
    },
  })

  await prisma.application.update({
    where: { id },
    data: {
      status: 'APPROVED',
      organizationId: org.id,
      reviewedById: 'admin', // TODO: set your real user id
      reviewedAt: new Date(),
      decisionNotes: notes || null,
    },
  })

  res.json({ ok: true, organizationId: org.id })
})

// REJECT
r.post('/:id/reject', async (req, res) => {
  const id = req.params.id
  const { reason } = req.body || {}

  const appRec = await prisma.application.findUnique({ where: { id } })
  if (!appRec) return res.status(404).json({ error: 'Not found' })
  if (appRec.status !== 'PENDING') return res.status(400).json({ error: 'Invalid state' })

  await prisma.application.update({
    where: { id },
    data: {
      status: 'REJECTED',
      reviewedById: 'admin', // TODO: current admin id
      reviewedAt: new Date(),
      decisionNotes: reason || null,
    },
  })

  res.json({ ok: true })
})

export default r
Register the router in your Express app (usually src/server.ts or index.ts):
import express from 'express'
import bodyParser from 'body-parser'
import adminApplications from './routes/adminApplications'

const app = express()
app.use(bodyParser.json())

app.use('/api/admin/applications', adminApplications)

// (your other routes here)

app.listen(5000, () => console.log('API on http://localhost:5000'))
Part 3 — Seed a Test Application (so you can see it)
Create prisma/seed.ts:
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()

async function main() {
  await prisma.application.create({
    data: {
      churchName: 'Grace Heritage Ministries',
      primaryContact: 'Pastor John Doe',
      email: 'pastor@example.com',
      subdomain: 'grace-heritage',
      answers: {
        "Mission focus": "Discipleship and community outreach",
        "Denomination": "Non-denominational",
        "Average attendance": "230",
        "Why join beta?": "We want to pilot assessments and volunteer matching",
      },
      attachments: [
        { name: '501c3.pdf', url: 'https://example.com/501c3.pdf' }
      ],
    }
  })
}

main().finally(() => prisma.$disconnect())
Run it:
npx ts-node prisma/seed.ts
(If you don’t use TypeScript, save as seed.js and run with node.)
Part 4 — Frontend (Admin UI)
A) Applications Queue Page
Route: /admin/applications
Shows PENDING by default with filters (PENDING / APPROVED / REJECTED).
Each row has a Review button that links to /admin/applications/:id.
Example React component (works with React Router or Next.js with minor tweaks):
// src/pages/admin/applications/index.tsx
import { useEffect, useState } from 'react'

export default function ApplicationsList() {
  const [items, setItems] = useState<any[]>([])
  const [status, setStatus] = useState('PENDING')

  useEffect(() => {
    fetch(`/api/admin/applications?status=${status}`).then(r => r.json()).then(setItems)
  }, [status])

  return (
    <div className="max-w-5xl mx-auto p-6 space-y-4">
      <h1 className="text-2xl font-semibold">Beta Applications</h1>

      <div className="flex gap-2">
        {['PENDING','APPROVED','REJECTED'].map(s => (
          <button
            key={s}
            onClick={() => setStatus(s)}
            className={`px-3 py-1 rounded ${status===s?'bg-indigo-600 text-white':'border'}`}
          >
            {s}
          </button>
        ))}
      </div>

      <div className="divide-y border rounded-lg">
        {items.map(app => (
          <div key={app.id} className="p-4 flex items-center justify-between">
            <div>
              <div className="font-medium">{app.churchName}</div>
              <div className="text-sm text-gray-500">{app.primaryContact} • {app.email}</div>
            </div>
            <a className="px-3 py-2 rounded bg-emerald-600 text-white"
               href={`/admin/applications/${app.id}`}>
              Review
            </a>
          </div>
        ))}
        {!items.length && <div className="p-6 text-gray-500">No applications</div>}
      </div>
    </div>
  )
}
B) Application Review Page
Route: /admin/applications/:id
Shows all answers, attachments, notes.
Buttons: Approve, Reject, Back to Queue.
// src/pages/admin/applications/[id].tsx
import { useEffect, useState } from 'react'

export default function ApplicationReview() {
  const id = window.location.pathname.split('/').pop() // replace with your router param
  const [app, setApp] = useState<any>(null)
  const [notes, setNotes] = useState('')

  useEffect(() => {
    fetch(`/api/admin/applications/${id}`).then(r => r.json()).then(setApp)
  }, [id])

  if (!app) return <div className="p-6">Loading…</div>

  const approve = async () => {
    const r = await fetch(`/api/admin/applications/${id}/approve`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ notes, subdomain: app.subdomain })
    }).then(r => r.json())
    alert('Approved! Opening org dashboard…')
    window.location.href = `/admin/orgs/${r.organizationId}` // link to your existing org page
  }

  const reject = async () => {
    await fetch(`/api/admin/applications/${id}/reject`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ reason: notes || 'Not a fit for beta' })
    })
    alert('Application rejected.')
    window.location.href = '/admin/applications'
  }

  return (
    <div className="max-w-5xl mx-auto p-6 space-y-6">
      <header className="flex items-center justify-between">
        <h1 className="text-2xl font-semibold">Review — {app.churchName}</h1>
        <span className="px-3 py-1 rounded-full bg-yellow-100 text-yellow-900 text-sm">{app.status}</span>
      </header>

      <section className="grid md:grid-cols-2 gap-6">
        <div className="border rounded-lg p-4">
          <h2 className="font-medium mb-2">Primary Contact</h2>
          <div>{app.primaryContact}</div>
          <div>{app.email}</div>
          <div>{app.phone || '—'}</div>
        </div>
        <div className="border rounded-lg p-4">
          <h2 className="font-medium mb-2">Requested URL</h2>
          <div>{app.subdomain ? `${app.subdomain}.kingdomops.org` : '—'}</div>
        </div>

        <div className="border rounded-lg p-4 md:col-span-2">
          <h2 className="font-medium mb-3">Application Answers</h2>
          <ul className="space-y-3">
            {Object.entries(app.answers || {}).map(([q, a]: any) => (
              <li key={q}>
                <div className="text-sm text-gray-500">{q}</div>
                <div className="font-medium">{String(a)}</div>
              </li>
            ))}
          </ul>
        </div>

        {Array.isArray(app.attachments) && app.attachments.length > 0 && (
          <div className="border rounded-lg p-4 md:col-span-2">
            <h2 className="font-medium mb-3">Attachments</h2>
            <ul className="list-disc ml-6">
              {app.attachments.map((f: any) => (
                <li key={f.url}><a href={f.url} target="_blank" rel="noreferrer">{f.name}</a></li>
              ))}
            </ul>
          </div>
        )}
      </section>

      <section className="border rounded-lg p-4">
        <h2 className="font-medium mb-2">Reviewer Notes</h2>
        <textarea className="w-full border rounded p-3" rows={4}
                  value={notes} onChange={e => setNotes(e.target.value)} />
      </section>

      <footer className="flex gap-3">
        <button onClick={approve} className="px-4 py-2 rounded bg-emerald-600 text-white">Approve</button>
        <button onClick={reject}  className="px-4 py-2 rounded bg-rose-600 text-white">Reject</button>
        <a href="/admin/applications" className="ml-auto px-4 py-2 rounded border">Back to Queue</a>
      </footer>
    </div>
  )
}
Part 5 — Wire Your Dashboard Tiles
Where you show those cards (Beta Applications, Approved Churches, Active Churches), fetch counts from the DB:
// example backend helper
export async function getDashboardCounts() {
  const [pending, approvedApps, activeOrgs] = await Promise.all([
    prisma.application.count({ where: { status: 'PENDING' }}),
    prisma.application.count({ where: { status: 'APPROVED' }}),
    prisma.organization.count(), // or { where: { onboardingComplete: true } } if you track it
  ])
  return { pending, approvedApps, activeOrgs }
}
Beta Applications → pending
Approved Churches (Ready to activate) → approvedApps
Active Churches → activeOrgs
Click behaviors
Pending tile → /admin/applications?status=PENDING
Approved tile → /admin/applications?status=APPROVED
Active tile → your existing /admin/orgs
And change your “Review Application” buttons in the queue to link to /admin/applications/:id (not the org dashboard).
Part 6 — Test the Flow (manual QA)
Start backend: npm run dev (or your script) → visit http://localhost:5000.
Visit /admin/applications on the frontend — you should see Grace Heritage Ministries from the seed.
Click Review → you should see the application review page (pastor answers visible).
Click Approve → you should be taken to /admin/orgs/{newOrgId}.
Go back to Applications and switch filter to APPROVED — the item should appear there.
Submit a real application from your public form — confirm it lands in PENDING.